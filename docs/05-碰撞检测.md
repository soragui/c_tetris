# 第 5 课：碰撞检测 🚧

## 5.1 什么是碰撞检测？

碰撞检测用于判断方块是否能移动到某个位置：

```
┌────────┐
│   ██   │  ← 方块
│   ██   │
└────────┘
    ↓
┌────────┐
│   ██   │  ← 可以移动
│   ██   │
└────────┘

┌────────┐
│   ██   │  ← 方块
│   ██   │
└────────┘
    ↓
  ┌──┐
  │██│  ← 碰撞！不能移动
  │██│
  └──┘
```

## 5.2 碰撞检测的条件

需要检查三种情况：

1. **超出左边界** - `x < 0`
2. **超出右边界** - `x >= BOARD_WIDTH`
3. **超出底边界** - `y >= BOARD_HEIGHT`
4. **碰到已固定的方块** - `board[y][x] != 0`

## 5.3 代码实现

```c
// tetromino.c
bool tetromino_check_collision(Tetromino* t, 
                               int board[BOARD_HEIGHT][BOARD_WIDTH]) {
    // 遍历方块的 4x4 矩阵
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            // 只检查有方块的部分
            if (t->shape[i][j]) {
                int x = t->x + j;  // 实际 X 坐标
                int y = t->y + i;  // 实际 Y 坐标
                
                // 1. 检查左右边界
                if (x < 0 || x >= BOARD_WIDTH) {
                    return true;  // 碰撞
                }
                
                // 2. 检查底边界
                if (y >= BOARD_HEIGHT) {
                    return true;  // 碰撞
                }
                
                // 3. 检查已固定的方块（忽略 y<0 的情况）
                if (y >= 0 && board[y][x]) {
                    return true;  // 碰撞
                }
            }
        }
    }
    return false;  // 无碰撞
}
```

## 5.4 碰撞检测的应用

### 移动方块

```c
// 尝试向左移动
game->current.x--;
if (board_check_collision(&game->board, &game->current)) {
    // 碰撞了，退回
    game->current.x++;
}
```

### 方块下落

```c
game->current.y++;
if (board_check_collision(&game->board, &game->current)) {
    // 碰撞了，退回并锁定
    game->current.y--;
    board_lock_tetromino(&game->board, &game->current);
}
```

### 方块旋转

```c
// 保存原状态
Tetromino temp = game->current;

// 尝试旋转
tetromino_rotate(&temp);

// 检查碰撞
if (!board_check_collision(&game->board, &temp)) {
    // 可以旋转，应用
    game->current = temp;
}
// 否则不旋转
```

## ✅ 本课检查清单

- [ ] 理解碰撞检测的原理
- [ ] 知道需要检测哪些边界
- [ ] 掌握碰撞检测的代码实现
- [ ] 会在移动、下落、旋转中应用

---

下一课：[方块旋转](07-方块旋转.md)
