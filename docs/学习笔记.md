# 📚 C 语言数据结构与算法学习笔记

> 结合教材理论与俄罗斯方块项目实践

---

## 目录

1. 链表 - 蛇的核心数据结构
2. 二维数组 - 游戏板实现
3. 栈和队列 - 游戏状态管理
4. 哈希表 - 快速查找优化
5. 树 - 场景图结构
6. 排序和搜索 - 碰撞检测优化
7. 几何算法 - 碰撞检测

---

## 1. 链表 🐍

### 理论概念

链表是由节点组成的线性数据结构，每个节点包含：
- 数据域 - 存储实际数据
- 指针域 - 指向下一个节点

### 项目应用：蛇的身体

```c
// 蛇身段 - 链表节点
typedef struct Segment {
    int x;                      // X 坐标（数据）
    int y;                      // Y 坐标（数据）
    struct Segment* next;       // 指向下一段（指针）
} Segment;

// 蛇 - 链表管理
typedef struct {
    Segment* head;              // 头部指针
    Segment* tail;              // 尾部指针
    int length;                 // 长度
} Snake;
```

### 关键操作

**1. 创建蛇（创建链表）**
```c
Snake* snake_create(int start_x, int start_y) {
    Snake* snake = malloc(sizeof(Snake));
    Segment* head = malloc(sizeof(Segment));
    head->x = start_x;
    head->y = start_y;
    head->next = NULL;
    snake->head = head;
    snake->tail = head;
    snake->length = 1;
    return snake;
}
```

**2. 蛇移动（链表头部插入）**
```c
void snake_move(Snake* snake, int new_x, int new_y) {
    Segment* new_head = malloc(sizeof(Segment));
    new_head->x = new_x;
    new_head->y = new_y;
    new_head->next = snake->head;
    snake->head = new_head;
    snake->length++;
}
```

**3. 销毁蛇（释放链表）**
```c
void snake_destroy(Snake* snake) {
    Segment* current = snake->head;
    while (current) {
        Segment* next = current->next;
        free(current);
        current = next;
    }
    free(snake);
}
```

### 为什么用链表？

| 方案 | 优点 | 缺点 |
|------|------|------|
| 链表 | 动态增长、插入删除快 | 随机访问慢 |
| 数组 | 随机访问快 | 大小固定、插入删除慢 |

**结论：** 蛇的长度动态变化，主要在头尾操作，链表是最优选择！

---

## 2. 二维数组 🎮

### 项目应用：游戏板

```c
#define BOARD_WIDTH   10
#define BOARD_HEIGHT  20

typedef struct {
    int cells[BOARD_HEIGHT][BOARD_WIDTH];
} Board;
```

### 关键操作

**消除行并下落**
```c
int board_clear_lines(Board* board) {
    int cleared = 0;
    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (is_row_full(board, y)) {
            cleared++;
            // 上面所有行下落一格
            for (int yy = y; yy > 0; yy--) {
                memcpy(board->cells[yy], 
                       board->cells[yy-1], 
                       sizeof(board->cells[0]));
            }
            y++;  // 重新检查当前行
        }
    }
    return cleared;
}
```

---

## 3. 栈和队列 📚

### 项目应用

**游戏状态栈（撤销功能）**
```c
#define MAX_HISTORY 10

typedef struct {
    GameState states[MAX_HISTORY];
    int top;
} StateStack;

void push_state(StateStack* stack, GameState state) {
    if (stack->top < MAX_HISTORY) {
        stack->states[stack->top++] = state;
    }
}

GameState pop_state(StateStack* stack) {
    if (stack->top > 0) {
        return stack->states[--stack->top];
    }
    return NULL;
}
```

---

## 4. 哈希表 ⚡

### 项目应用：最高分查询

```c
// 简单哈希函数（按名字首字母）
int hash_name(const char* name) {
    return name[0] % 26;
}

// 查找时间复杂度：O(1)
```

---

## 5. 几何算法 📐

### 碰撞检测

**边界检测**
```c
bool is_out_of_bounds(int x, int y) {
    return x < 0 || x >= BOARD_WIDTH || y >= BOARD_HEIGHT;
}
```

**方块与墙壁碰撞**
```c
bool check_wall_collision(Tetromino* t) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (t->shape[i][j]) {
                int x = t->x + j;
                int y = t->y + i;
                if (x < 0 || x >= BOARD_WIDTH || y >= BOARD_HEIGHT) {
                    return true;
                }
            }
        }
    }
    return false;
}
```

---

## 📝 学习总结

### 数据结构选择指南

| 需求 | 推荐数据结构 | 项目应用 |
|------|-------------|---------|
| 动态长度 | 链表 | 蛇的身体 |
| 固定大小网格 | 二维数组 | 游戏板 |
| 快速查找 | 哈希表 | 最高分查询 |
| 撤销功能 | 栈 | 游戏状态历史 |
| 输入缓冲 | 队列 | 玩家输入 |

### 最佳实践

1. 选择合适的数据结构 - 根据操作特点选择
2. 考虑时间和空间复杂度 - 权衡性能
3. 代码可读性 - 清晰的命名和注释
4. 内存管理 - 及时释放不用的内存
5. 边界条件 - 处理特殊情况

---

*最后更新：2026 年 2 月 27 日*
*作者：Fedora Boot 🐧*
